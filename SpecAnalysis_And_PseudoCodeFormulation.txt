Promise A+ Spec-Analysis & Pseudo Code formulation :

Spec URL:https://promisesaplus.com/

A) Analysis:

2.2 The "then" model:

"2.2.6 then may be called multiple times on the same promise.
If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.
If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then"

"2.2.7 then must return a promise ..."

Q: From 2.2.6, if then is called multiple times on same promise, then From 2.2.7, doesn't that means we are creating new promise everytime,
since then returns a promise as well,apart from registering callbacks? 
So didn't quite get from 2.2.6,"all respective onFulfilled callbacks must execute in the order of their originating calls" completely
i.e. for 2.2.6 to make sense, there should be an internal array/queue as well for each promise for registering all the then callballbacks in order.
If that is the case, what value does the new promise (or promises?) returned gets, how it's get evaluated based on all these different callbacks [onResolve1,onResolve2..]?
does that means it gets resolved in sequence?
ToDo:Revisit on this post covering basic flow of then() & constructor.


2.3 The resolution procedure [[Resolve]](promise,x) :

"If x is a thenable, it attempts to make promise adopt the state of x"

Q: Adopting the state is understandable if its' a promise, but if it's simply a thenable(i.e. object with then function) 
then most probably that is all it would have, i.e. no state vars only a  then function, so how to deduce it's state in that case? 
Maybe the next line "under the assumption that x behaves at least somewhat like a promise." is on the same lines. 
ie. we can only adopt it's state if it's a promise(a thenable)! but what do if it's not a promise? ToDo: Refer 2.3.3

Steps:
2.3.1 if x===promise ->  Reject with TypeError most probably in order to avoid infinite recursion.
2.3.2 else if x is a promise -> adopt
2.3.3 else if x is object/fn -> {
		//if x is object
			retrieve-> x.then 
			  // if Successfully retrieved with value v, resolve(v)->promise
			  // if Error with reason e, reject(e)->promise
		//if x is function which further contains "then" function
		        call-> x.then with this=x & it's own new set of (onRResolved,onRRejected) callbacks as 1st and 2nd args
			// so when, onRResolved is called with value v, resolve(v)->promise
			// & when onRRejected is called with reason e, reject(e)->promise
			// ignore any subsequent calls to onRResolved & onRRejected 
			
      }
2.3.4 else -> fulfill promise with x // We'll start the pseudo-code from here, being the simplest of all



B) Pseudo-Code :

onFulfilledArray:[]
onRejectedArray:[]
status=PENDING,value=undefined,reason=undefined

Promise then(onFulfilled, onRejected){
	if(onFulfilled typeOf function) onFulFilledArray.add(onFulfilled)
	if(onRejected typeOf function) onRejectedArray.add(onRejected)

	??? how to return new promise since it needs to be returned immediately
	??? return new Promise(executor)

	//noob attempt..
	return new Promise(function(resolve,reject){
		resolve(onFulfilled) ???
		reject(onRejected) ???
	});	
	
}

/*other important fns which will be required, not covered in spec*/

constructor()
resolve()
reject()


Promise(executor){
	//when executor completes, call:
	//if Success
		-- set value
		-- call resolve(value) 

	//if Error
		-- set reason
		-- call reject(reason) 
}

resolve(value){
	-- changes status to FULFILLED	
	-- call onFulfilledArray[0] ...
}

reject(reason){
	-- changes status to REJECTED 
	-- call onRejectedArray[0] ...
}































